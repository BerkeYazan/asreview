import {
  Link as LinkIcon,
  Visibility as VisibilityIcon,
  Close as CloseIcon,
  PictureAsPdf as PdfIcon,
  School as ScholarIcon,
  OpenInNew as OpenInNewIcon,
  Download as DownloadIcon,
  LocalLibrary as LibraryIcon,
  Description as DescriptionIcon,
  Key as KeyIcon,
  Search as SearchIcon,
  Fingerprint as FingerprintIcon,
  Article as ArticleIcon,
  AccessTime as AccessTimeIcon,
  Info as InfoIcon,
  CheckCircle as CheckCircleIcon,
} from "@mui/icons-material";
import {
  Box,
  Button,
  Card,
  CardContent,
  Collapse,
  Dialog,
  DialogContent,
  DialogTitle,
  Divider,
  Fade,
  Grid2 as Grid,
  IconButton,
  Link,
  Stack,
  Tooltip,
  Typography,
  CircularProgress,
  Paper,
  Chip,
} from "@mui/material";
import React from "react";

import { StyledIconButton } from "StyledComponents/StyledButton";
import { useToggle } from "hooks/useToggle";
import { DOIIcon } from "icons";
import { RecordCardLabeler, RecordCardModelTraining } from ".";

import { fontSizeOptions } from "globals.js";

// Function to calculate Levenshtein distance between two strings
const levenshteinDistance = (str1, str2) => {
  const track = Array(str2.length + 1)
    .fill(null)
    .map(() => Array(str1.length + 1).fill(null));

  for (let i = 0; i <= str1.length; i++) {
    track[0][i] = i;
  }
  for (let j = 0; j <= str2.length; j++) {
    track[j][0] = j;
  }

  for (let j = 1; j <= str2.length; j++) {
    for (let i = 1; i <= str1.length; i++) {
      const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
      track[j][i] = Math.min(
        track[j][i - 1] + 1, // deletion
        track[j - 1][i] + 1, // insertion
        track[j - 1][i - 1] + indicator, // substitution
      );
    }
  }
  return track[str2.length][str1.length];
};

// Paper Preview Dialog component
const PaperPreviewDialog = ({ open, onClose, record }) => {
  const [isLoading, setIsLoading] = React.useState(true);
  const [paperData, setPaperData] = React.useState(null);
  const [error, setError] = React.useState(null);
  const [isSearchingDoi, setIsSearchingDoi] = React.useState(false);
  const [foundDoi, setFoundDoi] = React.useState(null);
  const [errorMessage, setErrorMessage] = React.useState("");
  const [doiChoices, setDoiChoices] = React.useState([]);
  const [showDoiChoices, setShowDoiChoices] = React.useState(false);
  const [searchStage, setSearchStage] = React.useState(null); // Track current search stage
  const [searchProgress, setSearchProgress] = React.useState(0); // Track progress percentage
  const [searchMessages, setSearchMessages] = React.useState([]); // Show search progress messages

  // Function to normalize title for better comparison
  const normalizeTitle = (title) => {
    if (!title) return "";
    return title
      .toLowerCase()
      .replace(/[^\w\s]/g, "") // Remove ALL punctuation
      .replace(/\s+/g, " ") // Normalize whitespace
      .trim();
  };

  // Function for super aggressive normalization (only alphanumeric chars)
  const superNormalizeTitle = (title) => {
    if (!title) return "";
    return title.toLowerCase().replace(/[^a-z0-9]/gi, "");
  };

  // New function to search for DOI using multiple sources
  const searchForDoi = async () => {
    if (!record.title) {
      setErrorMessage("No title available to search for paper");
      return;
    }

    // Reset search state
    setIsSearchingDoi(true);
    setErrorMessage("");
    setDoiChoices([]);
    setShowDoiChoices(false);
    setSearchStage("initializing");
    setSearchProgress(5);
    setSearchMessages([{ text: "Searching...", timestamp: Date.now() }]);

    try {
      // Clean title for search
      const cleanTitle = record.title.trim();
      setSearchProgress(10);

      // Check if title appears to be a medical/biomedical paper
      const isMedicalPaper = checkIfMedicalPaper(cleanTitle);

      // Try PubMed FIRST for all papers (not just medical/biomedical papers)
      // PubMed has better exact matching for older papers and medical literature
      setSearchStage("pubmed");
      setSearchProgress(20);
      setSearchMessages([
        { text: "Searching PubMed...", timestamp: Date.now() },
      ]);

      const pubmedResults = await searchPubMed(cleanTitle);

      if (pubmedResults.success) {
        setSearchProgress(100);
        setIsSearchingDoi(false);
        return;
      }

      // Continue with CrossRef search only if PubMed fails
      setSearchStage("crossref");
      setSearchProgress(50);
      setSearchMessages([
        { text: "Searching CrossRef...", timestamp: Date.now() },
      ]);

      // Step 1: Try a direct search with the title in CrossRef
      const searchUrl = `https://api.crossref.org/works?query=${encodeURIComponent(cleanTitle)}&rows=30`;
      const response = await fetch(searchUrl);

      if (!response.ok) {
        throw new Error(`Crossref API error: ${response.status}`);
      }

      const data = await response.json();
      setSearchProgress(70);

      if (!data.message.items || data.message.items.length === 0) {
        // If no DOI found, try to find metadata using Semantic Scholar
        setSearchStage("semanticscholar");
        setSearchProgress(80);
        setSearchMessages([
          { text: "Searching Semantic Scholar...", timestamp: Date.now() },
        ]);
        await fetchPaperFromSemanticScholar(cleanTitle);
        return;
      }

      // Calculate Levenshtein ratio (similarity score between 0 and 1)
      const calculateLevenshteinRatio = (str1, str2) => {
        if (!str1 || !str2) return 0;

        // Super aggressive normalization - remove ALL non-alphanumeric chars and convert to lowercase
        const normalized1 = str1.toLowerCase().replace(/[^a-z0-9]/gi, "");
        const normalized2 = str2.toLowerCase().replace(/[^a-z0-9]/gi, "");

        // If they're identical after aggressive normalization, it's a perfect match
        if (normalized1 === normalized2) return 1.0;

        const longerLength = Math.max(normalized1.length, normalized2.length);
        if (longerLength === 0) return 1.0;

        // Get raw Levenshtein distance
        const distance = levenshteinDistance(normalized1, normalized2);

        // For very similar titles (1-2 character difference), boost the score
        if (distance <= 2) {
          return 0.95; // Consider almost perfect match
        }

        return (longerLength - distance) / longerLength;
      };

      // Less aggressive normalization for better matching of older papers
      const normalizeText = (text) => {
        if (!text) return "";
        return text
          .toLowerCase()
          .replace(/[^\w\s\-.,()]/g, "") // Keep more punctuation that might be significant
          .replace(/\s+/g, " ") // Normalize whitespace
          .trim();
      };

      const normalizedQueryTitle = normalizeText(cleanTitle);
      console.log("Normalized query title:", normalizedQueryTitle);

      // Super aggressive normalization for exact match testing
      const superNormalizedQueryTitle = cleanTitle
        .toLowerCase()
        .replace(/[^a-z0-9]/gi, "");

      // Score each result based on title similarity
      const scoredItems = data.message.items
        .filter((item) => item.title && item.title.length > 0 && item.DOI)
        .map((item) => {
          // Normal similarity
          const itemTitle = normalizeText(item.title[0]);
          const similarity = calculateLevenshteinRatio(
            normalizedQueryTitle,
            itemTitle,
          );

          // Super-aggressive normalization for exact match testing
          const superNormalizedItemTitle = item.title[0]
            .toLowerCase()
            .replace(/[^a-z0-9]/gi, "");
          const isExactAfterNormalization =
            superNormalizedQueryTitle === superNormalizedItemTitle;

          // If exact match after super normalization, boost score dramatically
          let finalSimilarity = similarity;
          if (isExactAfterNormalization) {
            finalSimilarity = 1.0;
            console.log(
              "Exact match found after aggressive normalization:",
              item.title[0],
            );
          }

          // For medical papers, also check for key term matches (like disease names)
          if (isMedicalPaper && !isExactAfterNormalization) {
            const queryKeyTerms = extractKeyTerms(cleanTitle);
            const itemKeyTerms = extractKeyTerms(item.title[0]);

            if (
              queryKeyTerms &&
              itemKeyTerms &&
              queryKeyTerms.toLowerCase() === itemKeyTerms.toLowerCase()
            ) {
              // Boost score when key medical terms match exactly
              finalSimilarity = Math.max(finalSimilarity, 0.85);
              console.log("Medical key terms match:", queryKeyTerms);
            }
          }

          // Consider publication year if available - give higher weight to year matches
          let yearMatch = false;
          if (record.year && item.published) {
            const recordYear = parseInt(record.year);
            const itemYear = parseInt(item.published["date-parts"][0][0]);
            yearMatch =
              !isNaN(recordYear) && !isNaN(itemYear) && recordYear === itemYear;
          }

          // Get the journal/publication name if available
          const journal =
            item["container-title"] && item["container-title"].length > 0
              ? item["container-title"][0]
              : null;

          // Get publication year
          const year = item.published
            ? new Date(item.published["date-parts"][0][0], 0, 1).getFullYear()
            : null;

          return {
            title: item.title[0],
            doi: item.DOI,
            similarity: finalSimilarity,
            yearMatch,
            year,
            journal,
            score: finalSimilarity + (yearMatch ? 0.15 : 0), // Give more weight to year matches for older papers
            originalItem: item,
            isExactMatch: isExactAfterNormalization,
          };
        })
        .sort((a, b) => b.score - a.score);

      console.log("Top 5 matches with Levenshtein ratio:");
      scoredItems.slice(0, 5).forEach((item, i) => {
        console.log(
          `${i + 1}. Similarity: ${item.similarity.toFixed(3)}, Score: ${item.score.toFixed(3)}, Title: "${item.title}"`,
        );
      });

      // Direct exact match has high confidence - slightly higher threshold (0.9 instead of 0.95)
      const bestMatch = scoredItems.length > 0 ? scoredItems[0] : null;

      // If we have an exact match after normalization OR high similarity score
      // For medical papers, we can be a bit more lenient (0.8 instead of 0.9)
      const similarityThreshold = isMedicalPaper ? 0.8 : 0.9;

      if (
        bestMatch &&
        (bestMatch.isExactMatch || bestMatch.similarity >= similarityThreshold)
      ) {
        console.log(
          `Found match with high similarity ${bestMatch.similarity.toFixed(3)}:`,
          bestMatch.title,
        );
        console.log("DOI:", bestMatch.doi);

        setFoundDoi(bestMatch.doi);
        setIsLoading(true);
        setPaperData((prevData) => ({
          ...prevData,
          doi: bestMatch.doi,
          year: bestMatch.year || prevData.year,
          journal: bestMatch.journal || prevData.journal,
        }));

        // Fetch additional information using the found DOI
        fetchPaperDataWithDoi(bestMatch.doi);
        return;
      }

      // Otherwise, collect several top matches to present as choices
      // Lower threshold for medical papers
      const threshold = isMedicalPaper ? 0.35 : 0.45;
      const potentialMatches = scoredItems
        .filter((item) => item.similarity >= threshold)
        .slice(0, 8); // Show up to 8 matches

      if (potentialMatches.length === 0) {
        console.log("No DOI matches above threshold, trying Semantic Scholar");
        await fetchPaperFromSemanticScholar(cleanTitle);
        return;
      }

      // Show choices to the user
      setDoiChoices(potentialMatches);
      setShowDoiChoices(true);
    } catch (err) {
      console.error("Error searching for DOI:", err);
      setErrorMessage(`Error: ${err.message || "Failed to search for DOI"}`);

      // Try Semantic Scholar as fallback even after an error
      try {
        await fetchPaperFromSemanticScholar(record.title.trim());
      } catch (semanticErr) {
        console.error(
          "Both DOI and Semantic Scholar searches failed:",
          semanticErr,
        );
      }
    } finally {
      setIsSearchingDoi(false);
    }
  };

  // Helper function to check if a paper title appears to be medical/biomedical
  const checkIfMedicalPaper = (title) => {
    if (!title) return false;

    // List of medical terms/patterns to check for
    const medicalPatterns = [
      /disease/i,
      /syndrome/i,
      /clinical/i,
      /patient/i,
      /therapy/i,
      /treatment/i,
      /diagnosis/i,
      /pathology/i,
      /medicine/i,
      /medical/i,
      /health/i,
      /imaging/i,
      /mri/i,
      /ct/i,
      /tomography/i,
      /resonance/i,
    ];

    // Check if any patterns match the title
    return medicalPatterns.some((pattern) => pattern.test(title));
  };

  // Function to fetch paper from Semantic Scholar when no DOI is found
  const fetchPaperFromSemanticScholar = async (title) => {
    try {
      console.log("Searching Semantic Scholar for:", title);

      // Semantic Scholar API to search for papers by title
      const searchUrl = `https://api.semanticscholar.org/graph/v1/paper/search?query=${encodeURIComponent(title)}&limit=10&fields=title,url,venue,year,authors,abstract,citationCount,openAccessPdf,externalIds`;

      const response = await fetch(searchUrl);

      if (!response.ok) {
        throw new Error(`Semantic Scholar API error: ${response.status}`);
      }

      const data = await response.json();

      if (!data.data || data.data.length === 0) {
        setErrorMessage("No papers found on Semantic Scholar");
        return;
      }

      // Find the best match based on title similarity
      const bestMatch = findBestTitleMatch(title, data.data);

      if (!bestMatch) {
        setErrorMessage("No good matches found on Semantic Scholar");
        return;
      }

      console.log("Found paper on Semantic Scholar:", bestMatch.title);

      // Check if the paper has a DOI
      if (bestMatch.externalIds && bestMatch.externalIds.DOI) {
        // If DOI exists, use it to fetch more comprehensive data
        setFoundDoi(bestMatch.externalIds.DOI);
        fetchPaperDataWithDoi(bestMatch.externalIds.DOI);
        return;
      }

      // Determine access status
      let accessStatus = "Subscription Required";
      let openAccess = false;

      if (bestMatch.openAccessPdf && bestMatch.openAccessPdf.url) {
        accessStatus = "Open Access";
        openAccess = true;
      }

      // Create paper data from Semantic Scholar results
      const paperMetadata = {
        title: bestMatch.title,
        abstract:
          bestMatch.abstract || record.abstract || "No abstract available",
        authors: bestMatch.authors
          ? bestMatch.authors.map((author) => ({ name: author.name }))
          : [],
        year: bestMatch.year,
        journal: bestMatch.venue,
        citations: bestMatch.citationCount,
        directPdfLink: bestMatch.openAccessPdf
          ? bestMatch.openAccessPdf.url
          : null,
        openAccess: openAccess,
        accessStatus: accessStatus,
        semanticScholarUrl: bestMatch.url,
        doi: null, // No DOI found
      };

      setPaperData(paperMetadata);
      setIsLoading(false);

      console.log("Paper metadata from Semantic Scholar:", paperMetadata);
    } catch (err) {
      console.error("Error fetching from Semantic Scholar:", err);
      setErrorMessage(
        `Could not find paper on Semantic Scholar: ${err.message}`,
      );
      setIsLoading(false);
    }
  };

  // Function to calculate title similarity using multiple methods
  const calculateTitleSimilarity = (title1, title2) => {
    if (!title1 || !title2) return 0;

    // Normalize both titles for comparison - remove ALL punctuation
    const normalized1 = normalizeTitle(title1);
    const normalized2 = normalizeTitle(title2);

    // Check for exact match after normalization
    if (normalized1 === normalized2) {
      return 1.0;
    }

    // Character-level similarity (Jaccard similarity for characters)
    const chars1 = new Set(normalized1.split(""));
    const chars2 = new Set(normalized2.split(""));
    const intersectionSize = [...chars1].filter((char) =>
      chars2.has(char),
    ).length;
    const unionSize = chars1.size + chars2.size - intersectionSize;
    const charSimilarity = intersectionSize / unionSize;

    // Word-level similarity (Jaccard similarity for words)
    const words1 = new Set(normalized1.split(" "));
    const words2 = new Set(normalized2.split(" "));
    const wordIntersectionSize = [...words1].filter((word) =>
      words2.has(word),
    ).length;
    const wordUnionSize = words1.size + words2.size - wordIntersectionSize;
    const wordSimilarity = wordIntersectionSize / wordUnionSize;

    // Check if one title is contained in the other
    const containmentScore =
      normalized1.includes(normalized2) || normalized2.includes(normalized1)
        ? 0.3
        : 0;

    // Check length difference (penalize big differences)
    const lengthDiffFactor =
      1 -
      Math.abs(normalized1.length - normalized2.length) /
        Math.max(normalized1.length, normalized2.length);

    // Weighted average (emphasizing word similarity and length match)
    return (
      0.3 * charSimilarity +
      0.5 * wordSimilarity +
      containmentScore +
      0.2 * lengthDiffFactor
    );
  };

  // Function to find the best title match from Semantic Scholar results
  const findBestTitleMatch = (queryTitle, papers) => {
    if (!papers || papers.length === 0) return null;

    const normalizedQuery = normalizeTitle(queryTitle);
    const superNormalizedQuery = superNormalizeTitle(queryTitle);

    // Calculate similarity scores
    const scoredPapers = papers
      .map((paper) => {
        const normalizedTitle = normalizeTitle(paper.title);
        const superNormalizedTitle = superNormalizeTitle(paper.title);

        // Check for exact match after normalization
        if (
          normalizedQuery === normalizedTitle ||
          superNormalizedQuery === superNormalizedTitle
        ) {
          return { paper, similarity: 1.0 };
        }

        // Calculate Levenshtein distance for close matches
        const levenDistance = levenshteinDistance(
          normalizedQuery,
          normalizedTitle,
        );
        if (levenDistance <= 3) {
          // For very close matches (only few characters different)
          return { paper, similarity: 0.95 - levenDistance * 0.05 };
        }

        // Simple word overlap score with more weight
        const queryWords = new Set(normalizedQuery.split(/\s+/));
        const titleWords = new Set(normalizedTitle.split(/\s+/));

        const intersection = [...queryWords].filter((word) =>
          titleWords.has(word),
        ).length;
        const union = queryWords.size + titleWords.size - intersection;

        // Calculate Jaccard similarity for word overlap
        const wordSimilarity = union > 0 ? intersection / union : 0;

        // Also check if one title contains the other (partial match)
        const containmentFactor =
          normalizedTitle.includes(normalizedQuery) ||
          normalizedQuery.includes(normalizedTitle)
            ? 0.3
            : 0;

        // Combined score - give more weight to word similarity for medical papers
        const similarity = wordSimilarity * 0.7 + containmentFactor;

        return {
          paper,
          similarity,
        };
      })
      .sort((a, b) => b.similarity - a.similarity);

    // Return the best match if it's above a certain threshold
    // Lower threshold to 0.25 to catch more potential matches
    if (scoredPapers.length > 0 && scoredPapers[0].similarity > 0.25) {
      return scoredPapers[0].paper;
    }

    // Otherwise, just return the first result as a fallback
    return papers[0];
  };

  // Function to select a DOI from the choices
  const selectDoi = (choice) => {
    setShowDoiChoices(false);
    setFoundDoi(choice.doi);
    setIsLoading(true);

    // Update paper data with the found DOI
    setPaperData((prevData) => ({
      ...prevData,
      doi: choice.doi,
      year: choice.year || prevData.year,
      journal: choice.journal || prevData.journal,
    }));

    // Fetch additional information using the chosen DOI
    fetchPaperDataWithDoi(choice.doi);
  };

  // Update paper data with the found DOI and related information
  const updatePaperWithFoundDoi = (crossrefItem) => {
    setPaperData((prevData) => ({
      ...prevData,
      doi: crossrefItem.DOI,
      year: crossrefItem.published
        ? new Date(
            crossrefItem.published["date-parts"][0][0],
            0,
            1,
          ).getFullYear()
        : prevData.year,
      journal:
        crossrefItem["container-title"] &&
        crossrefItem["container-title"].length > 0
          ? crossrefItem["container-title"][0]
          : prevData.journal,
    }));

    // Fetch additional information using OpenAlex with the found DOI
    fetchPaperDataWithDoi(crossrefItem.DOI);
  };

  // Fetch additional data with a DOI
  const fetchPaperDataWithDoi = async (doi) => {
    try {
      const openAlexUrl = `https://api.openalex.org/works/https://doi.org/${encodeURIComponent(doi)}`;
      const response = await fetch(openAlexUrl);

      if (response.ok) {
        const data = await response.json();

        // Update with enhanced metadata
        setPaperData((prevData) => {
          const updated = { ...prevData };

          // Get author information if available
          if (data.authorships && data.authorships.length > 0) {
            updated.authors = data.authorships.map((authorship) => ({
              name: authorship.author.display_name,
              affiliations:
                authorship.institutions?.map((inst) => inst.display_name) || [],
            }));
          }

          // Get publication info
          if (data.publication_date) {
            updated.year = new Date(data.publication_date).getFullYear();
          }

          // Get journal/source info
          if (data.primary_location && data.primary_location.source) {
            updated.journal = data.primary_location.source.display_name;
          } else if (data.host_venue && data.host_venue.display_name) {
            updated.journal = data.host_venue.display_name;
          }

          // Get citation count
          if (data.cited_by_count !== undefined) {
            updated.citations = data.cited_by_count;
          }

          // Determine access status more precisely
          if (data.open_access) {
            if (data.open_access.is_oa) {
              updated.openAccess = true;
              updated.accessStatus = "Open Access";

              // Check if we have a direct PDF link
              if (data.open_access.oa_url) {
                updated.directPdfLink = data.open_access.oa_url;
              }
            } else {
              updated.openAccess = false;
              updated.accessStatus = "Subscription Required";
            }
          }

          // Look for PDF links in locations
          if (
            !updated.directPdfLink &&
            data.primary_location &&
            data.primary_location.pdf_url
          ) {
            updated.directPdfLink = data.primary_location.pdf_url;
            if (!updated.openAccess) {
              updated.accessStatus = "PDF Available";
            }
          }

          if (!updated.directPdfLink && data.locations) {
            for (const location of data.locations) {
              if (location.pdf_url) {
                updated.directPdfLink = location.pdf_url;
                if (!updated.openAccess) {
                  updated.accessStatus = "PDF Available";
                }
                break;
              }
            }
          }

          // Ensure we're no longer in loading state
          setIsLoading(false);

          return updated;
        });
      } else {
        // Set a default access status if OpenAlex request fails
        setPaperData((prevData) => ({
          ...prevData,
          accessStatus: "Subscription Required",
        }));
        setIsLoading(false);
      }
    } catch (err) {
      console.log("OpenAlex fetch error with found DOI:", err);
      // Set a default access status if fetch fails
      setPaperData((prevData) => ({
        ...prevData,
        accessStatus: "Subscription Required",
      }));
      setIsLoading(false);
    }
  };

  // Load paper metadata from OpenAlex
  React.useEffect(() => {
    if (!open) return;

    setIsLoading(true);
    setError(null);
    setPaperData(null);
    setFoundDoi(null);

    const fetchPaperData = async () => {
      try {
        // First build basic data from the record itself
        const basicData = {
          title: record.title || "Untitled Paper",
          abstract: record.abstract || "No abstract available",
          doi: record.doi,
          url: record.url,
          authors: [],
          year: null,
          journal: null,
          citations: null,
          directPdfLink: null,
          openAccess: false,
          accessStatus: "Unknown", // Default status
        };

        // Try to get enhanced metadata from OpenAlex if DOI is available
        if (record.doi) {
          try {
            const openAlexUrl = `https://api.openalex.org/works/https://doi.org/${encodeURIComponent(record.doi)}`;
            const response = await fetch(openAlexUrl);

            if (response.ok) {
              const data = await response.json();

              // Get author information
              if (data.authorships && data.authorships.length > 0) {
                basicData.authors = data.authorships.map((authorship) => ({
                  name: authorship.author.display_name,
                  affiliations:
                    authorship.institutions?.map((inst) => inst.display_name) ||
                    [],
                }));
              }

              // Get publication info
              if (data.publication_date) {
                basicData.year = new Date(data.publication_date).getFullYear();
              }

              // Get journal/source info
              if (data.primary_location && data.primary_location.source) {
                basicData.journal = data.primary_location.source.display_name;
              } else if (data.host_venue && data.host_venue.display_name) {
                basicData.journal = data.host_venue.display_name;
              }

              // Get citation count
              if (data.cited_by_count !== undefined) {
                basicData.citations = data.cited_by_count;
              }

              // Determine access status more precisely
              if (data.open_access) {
                if (data.open_access.is_oa) {
                  basicData.openAccess = true;
                  basicData.accessStatus = "Open Access";

                  // Check if we have a direct PDF link
                  if (data.open_access.oa_url) {
                    basicData.directPdfLink = data.open_access.oa_url;
                  }
                } else {
                  basicData.openAccess = false;
                  basicData.accessStatus = "Subscription Required";
                }
              }

              // Look for PDF links in locations if we don't have one yet
              if (
                !basicData.directPdfLink &&
                data.primary_location &&
                data.primary_location.pdf_url
              ) {
                basicData.directPdfLink = data.primary_location.pdf_url;
                if (!basicData.openAccess) {
                  basicData.accessStatus = "PDF Available"; // We have a PDF but not sure about OA status
                }
              }

              if (!basicData.directPdfLink && data.locations) {
                for (const location of data.locations) {
                  if (location.pdf_url) {
                    basicData.directPdfLink = location.pdf_url;
                    if (!basicData.openAccess) {
                      basicData.accessStatus = "PDF Available";
                    }
                    break;
                  }
                }
              }

              // Try Unpaywall for PDF link if we still don't have one
              if (!basicData.directPdfLink) {
                try {
                  const unpaywallUrl = `https://api.unpaywall.org/v2/${basicData.doi}?email=asreview@example.com`;
                  const unpaywallResponse = await fetch(unpaywallUrl);

                  if (unpaywallResponse.ok) {
                    const unpaywallData = await unpaywallResponse.json();

                    if (
                      unpaywallData.is_oa &&
                      unpaywallData.best_oa_location &&
                      unpaywallData.best_oa_location.url_for_pdf
                    ) {
                      basicData.directPdfLink =
                        unpaywallData.best_oa_location.url_for_pdf;
                      basicData.openAccess = true;
                      basicData.accessStatus = "Open Access";
                    }
                  }
                } catch (err) {
                  console.log("Unpaywall API error:", err);
                }
              }
            }
          } catch (err) {
            console.log("OpenAlex fetch error:", err);
            basicData.accessStatus = "Subscription Required";
          }
        }
        // If no DOI but we have a title, try to auto-search for the paper info
        else if (record.title) {
          // Only auto-search for papers that look like medical/scientific papers
          const isMedicalPaper = checkIfMedicalPaper(record.title);

          if (isMedicalPaper) {
            setPaperData(basicData);
            // Trigger automatic search for medical papers
            setTimeout(() => {
              searchForDoi();
            }, 500);
          }
        }

        setPaperData(basicData);
        setIsLoading(false);
      } catch (err) {
        console.error("Error fetching paper metadata:", err);
        setError("Unable to load paper information.");
        setIsLoading(false);
      }
    };

    fetchPaperData();
  }, [open, record]);

  // Get the appropriate external URL for opening in browser
  const getExternalUrl = () => {
    if (foundDoi || record.doi) {
      return `https://doi.org/${foundDoi || record.doi}`;
    } else if (paperData?.pubmedUrl) {
      return paperData.pubmedUrl;
    } else if (paperData?.semanticScholarUrl) {
      return paperData.semanticScholarUrl;
    } else if (record.url) {
      return record.url;
    }
    return null;
  };

  // Get Google Scholar search URL
  const getGoogleScholarUrl = () => {
    if (record.title) {
      return `https://scholar.google.com/scholar?q=${encodeURIComponent(record.title)}`;
    }
    return "https://scholar.google.com";
  };

  // Get Sci-Hub URL - only works with DOI
  const getSciHubUrl = () => {
    if (foundDoi || record.doi) {
      return `https://sci-hub.se/${foundDoi || record.doi}`;
    }
    return null; // No URL if no DOI
  };

  // Get access status color
  const getAccessStatusColor = (status) => {
    switch (status) {
      case "Open Access":
        return "success";
      case "PDF Available":
        return "info";
      case "Subscription Required":
        return "warning";
      default:
        return "default";
    }
  };

  // New function to search PubMed
  const searchPubMed = async (title) => {
    try {
      // Clean title for search - keep some punctuation for the API search
      const searchableTitle = title.trim();

      // Also create super normalized versions for exact match detection
      const superNormalized = superNormalizeTitle(title);

      console.log("Searching PubMed for:", searchableTitle);
      console.log("Super normalized search title:", superNormalized);

      // First search for the paper by title
      const searchUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pubmed&term=${encodeURIComponent(searchableTitle)}&retmode=json&sort=relevance`;
      const searchResponse = await fetch(searchUrl);

      if (!searchResponse.ok) {
        return {
          success: false,
          message: `PubMed search error: ${searchResponse.status}`,
        };
      }

      const searchData = await searchResponse.json();
      const ids = searchData.esearchresult.idlist;

      if (!ids || ids.length === 0) {
        // Try a more relaxed search if exact title fails
        // Remove punctuation for relaxed search
        const normalizedTitle = normalizeTitle(title);
        const relaxedTitle = normalizedTitle.split(" ").slice(0, 8).join(" "); // Use first 8 words
        setSearchMessages((prev) => [
          ...prev,
          { text: "Trying relaxed search in PubMed...", timestamp: Date.now() },
        ]);

        const relaxedUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pubmed&term=${encodeURIComponent(relaxedTitle)}&retmode=json&sort=relevance`;
        const relaxedResponse = await fetch(relaxedUrl);

        if (!relaxedResponse.ok) {
          return {
            success: false,
            message: "No results from relaxed PubMed search",
          };
        }

        const relaxedData = await relaxedResponse.json();
        const relaxedIds = relaxedData.esearchresult.idlist;

        if (!relaxedIds || relaxedIds.length === 0) {
          // Try an even more aggressive search with just the key terms
          // For medical papers like "Wilson's disease", focus on the key disease/condition terms
          const keyTerms = extractKeyTerms(title);
          if (keyTerms) {
            setSearchMessages((prev) => [
              ...prev,
              {
                text: `Searching with key terms: ${keyTerms}`,
                timestamp: Date.now(),
              },
            ]);

            const keyTermsUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pubmed&term=${encodeURIComponent(keyTerms)}&retmode=json&sort=relevance`;
            const keyTermsResponse = await fetch(keyTermsUrl);

            if (keyTermsResponse.ok) {
              const keyTermsData = await keyTermsResponse.json();
              const keyTermsIds = keyTermsData.esearchresult.idlist;

              if (keyTermsIds && keyTermsIds.length > 0) {
                return await fetchPubMedDetails(
                  keyTermsIds.slice(0, 20),
                  title,
                  true,
                );
              }
            }
          }

          return { success: false, message: "No matches found in PubMed" };
        }

        // Use the relaxed results
        setSearchMessages((prev) => [
          ...prev,
          {
            text: `Found ${relaxedIds.length} potential matches with relaxed search`,
            timestamp: Date.now(),
          },
        ]);
        return await fetchPubMedDetails(relaxedIds, title, true);
      }

      // If we have results, fetch the details
      setSearchMessages((prev) => [
        ...prev,
        {
          text: `Found ${ids.length} potential matches in PubMed`,
          timestamp: Date.now(),
        },
      ]);
      return await fetchPubMedDetails(ids, title);
    } catch (err) {
      console.error("PubMed search error:", err);
      return {
        success: false,
        message: `Error searching PubMed: ${err.message}`,
      };
    }
  };

  // Helper function to extract key medical terms from a title
  const extractKeyTerms = (title) => {
    if (!title) return null;

    // First look for common disease patterns like "X disease" or "X syndrome"
    const diseaseMatch =
      title.match(/([A-Za-z']+('s)?\s+disease)/i) ||
      title.match(/([A-Za-z']+('s)?\s+syndrome)/i);

    if (diseaseMatch && diseaseMatch[1]) {
      return diseaseMatch[1];
    }

    // If no specific pattern found, take first 2-3 significant words
    const words = title.split(/\s+/).filter((w) => w.length > 3);
    if (words.length >= 2) {
      return words.slice(0, 3).join(" ");
    }

    return null;
  };

  // Function to fetch PubMed article details
  const fetchPubMedDetails = async (
    ids,
    originalTitle,
    isRelaxedSearch = false,
  ) => {
    try {
      // Get both normalized and super-normalized versions of the title
      const normalizedQueryTitle = normalizeTitle(originalTitle);
      const superNormalizedQueryTitle = superNormalizeTitle(originalTitle);

      console.log("Normalized query title for PubMed:", normalizedQueryTitle);
      console.log(
        "Super normalized query title for PubMed:",
        superNormalizedQueryTitle,
      );

      // Limit to top 10 results for older papers (instead of 5)
      const topIds = ids.slice(0, 10);
      const summaryUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?db=pubmed&id=${topIds.join(",")}&retmode=json`;
      const detailsResponse = await fetch(summaryUrl);

      if (!detailsResponse.ok) {
        return {
          success: false,
          message: `PubMed details error: ${detailsResponse.status}`,
        };
      }

      const detailsData = await detailsResponse.json();
      const articles = Object.values(detailsData.result).filter(
        (item) => item.uid,
      );

      if (!articles || articles.length === 0) {
        return {
          success: false,
          message: "Could not retrieve article details from PubMed",
        };
      }

      // Score and sort articles by title similarity
      const scoredArticles = articles
        .map((article) => {
          // Get multiple normalization versions
          const normalizedTitle = normalizeTitle(article.title);
          const superNormalizedTitle = superNormalizeTitle(article.title);

          // Check for exact match after different normalizations
          const isExactMatch = normalizedQueryTitle === normalizedTitle;
          const isSuperExactMatch =
            superNormalizedQueryTitle === superNormalizedTitle;

          // Calculate traditional similarity
          let similarity = 0;

          // If either normalization produces an exact match, set to 1.0
          if (isExactMatch || isSuperExactMatch) {
            similarity = 1.0;
            console.log(
              "Exact match found in PubMed after normalization:",
              article.title,
            );
          } else {
            // Calculate word overlap for non-exact matches
            const queryWords = new Set(normalizedQueryTitle.split(" "));
            const titleWords = new Set(normalizedTitle.split(" "));

            const intersection = [...queryWords].filter((word) =>
              titleWords.has(word),
            ).length;
            const union = queryWords.size + titleWords.size - intersection;

            similarity = union > 0 ? intersection / union : 0;

            // Check if it's a near match (1-2 character difference)
            const levenDistance = levenshteinDistance(
              normalizedQueryTitle,
              normalizedTitle,
            );
            if (levenDistance <= 2) {
              similarity = 0.95; // Boost near matches
              console.log(
                "Near match found in PubMed, Levenshtein distance:",
                levenDistance,
                article.title,
              );
            }
          }

          return {
            ...article,
            similarity,
            isExactMatch: isExactMatch || isSuperExactMatch,
          };
        })
        .sort((a, b) => {
          // Sort exact matches first, then by similarity
          if (a.isExactMatch && !b.isExactMatch) return -1;
          if (!a.isExactMatch && b.isExactMatch) return 1;
          return b.similarity - a.similarity;
        });

      // Debug the top 3 matches
      console.log("Top 3 matches from PubMed:");
      scoredArticles.slice(0, 3).forEach((article, i) => {
        console.log(
          `${i + 1}. Score: ${article.similarity.toFixed(2)}, Title: "${article.title}"`,
        );
      });

      // If we have a good match (exact match, high similarity, or forced relaxed)
      const bestMatch = scoredArticles[0];

      if (
        bestMatch.isExactMatch ||
        bestMatch.similarity > 0.7 ||
        (isRelaxedSearch && bestMatch.similarity > 0.4)
      ) {
        // We found a good match! Extract the details
        const pubmedId = bestMatch.uid;
        let doi = null;

        // Look for DOI in article identifiers
        if (bestMatch.articleids) {
          const doiObj = bestMatch.articleids.find((id) => id.idtype === "doi");
          if (doiObj) {
            doi = doiObj.value;
          }
        }

        // Create basic paper data
        const pubDate = bestMatch.pubdate ? new Date(bestMatch.pubdate) : null;
        const year = pubDate ? pubDate.getFullYear() : null;

        // Update paper data
        const paperMetadata = {
          title: bestMatch.title,
          abstract:
            bestMatch.abstract || record.abstract || "No abstract available",
          authors: bestMatch.authors
            ? bestMatch.authors.map((author) => ({ name: author.name }))
            : [],
          year: year,
          journal: bestMatch.fulljournalname || bestMatch.source,
          pubmedId: pubmedId,
          doi: doi,
          pubmedUrl: `https://pubmed.ncbi.nlm.nih.gov/${pubmedId}/`,
          // Default to subscription required unless we find evidence of open access
          accessStatus: "Subscription Required",
          openAccess: false,
        };

        // If we found a DOI, set it and fetch additional data
        if (doi) {
          setFoundDoi(doi);
          setSearchMessages((prev) => [
            ...prev,
            { text: `Found DOI: ${doi}`, timestamp: Date.now() },
          ]);
          fetchPaperDataWithDoi(doi);
          return {
            success: true,
            message: `Found DOI: ${doi}`,
          };
        } else {
          // No DOI, but we still have PubMed information
          setSearchMessages((prev) => [
            ...prev,
            {
              text: `Found paper in PubMed (no DOI available)`,
              timestamp: Date.now(),
            },
          ]);

          // Try to check free availability through PMC
          try {
            const pmcUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/elink.fcgi?dbfrom=pubmed&db=pmc&linkname=pubmed_pmc&id=${pubmedId}&retmode=json`;
            const pmcResponse = await fetch(pmcUrl);

            if (pmcResponse.ok) {
              const pmcData = await pmcResponse.json();

              // Check if there's a PMC link (indicating free fulltext)
              if (
                pmcData.linksets &&
                pmcData.linksets[0].linksetdbs &&
                pmcData.linksets[0].linksetdbs.length > 0
              ) {
                const pmcLinks = pmcData.linksets[0].linksetdbs.find(
                  (db) => db.linkname === "pubmed_pmc",
                );

                if (pmcLinks && pmcLinks.links && pmcLinks.links.length > 0) {
                  const pmcId = pmcLinks.links[0];
                  paperMetadata.pmcId = pmcId;
                  paperMetadata.directPdfLink = `https://www.ncbi.nlm.nih.gov/pmc/articles/PMC${pmcId}/pdf/`;
                  paperMetadata.accessStatus = "Open Access";
                  paperMetadata.openAccess = true;
                }
              }
            }
          } catch (err) {
            console.log("Error checking PMC availability:", err);
          }

          setPaperData(paperMetadata);
          setIsLoading(false);

          return {
            success: true,
            message: "Found paper in PubMed (no DOI available)",
          };
        }
      } else if (scoredArticles.length > 1) {
        // Present multiple options to the user if we have several possible matches
        const potentialMatches = scoredArticles
          .filter((article) => article.similarity > 0.3)
          .map((article) => {
            // Extract DOI if available
            let doi = null;
            if (article.articleids) {
              const doiObj = article.articleids.find(
                (id) => id.idtype === "doi",
              );
              if (doiObj) {
                doi = doiObj.value;
              }
            }

            // Extract year from pubdate
            const pubDate = article.pubdate ? new Date(article.pubdate) : null;
            const year = pubDate ? pubDate.getFullYear() : null;

            return {
              title: article.title,
              similarity: article.similarity,
              doi: doi,
              year: year,
              journal: article.fulljournalname || article.source,
              pubmedId: article.uid,
              score: article.similarity, // Use similarity as score
            };
          });

        if (potentialMatches.length > 0) {
          setDoiChoices(potentialMatches);
          setShowDoiChoices(true);
          setIsSearchingDoi(false);
          setSearchProgress(100);
          return { success: true, message: "Multiple potential matches found" };
        }
      }

      return { success: false, message: "No close matches found in PubMed" };
    } catch (err) {
      console.error("Error fetching PubMed details:", err);
      return {
        success: false,
        message: `Error processing PubMed results: ${err.message}`,
      };
    }
  };

  return (
    <Dialog
      open={open}
      onClose={onClose}
      fullWidth
      maxWidth="md"
      sx={{
        "& .MuiDialog-paper": {
          borderRadius: 2.5,
          overflow: "hidden",
        },
      }}
    >
      <DialogTitle
        sx={(theme) => ({
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          padding: theme.spacing(2, 3),
          bgcolor: "transparent",
          borderBottom: `1px solid ${theme.palette.divider}`,
        })}
      >
        <Stack direction="row" spacing={1} alignItems="center">
          {/* Show appropriate chip in header based on state */}
          {isLoading && !isSearchingDoi ? (
            <Chip
              label="Loading..."
              size="small"
              variant="outlined"
              sx={{
                height: 28,
                fontWeight: "regular",
                fontSize: "0.8125rem",
                bgcolor: (theme) =>
                  theme.palette.mode === "light"
                    ? "rgba(0,0,0,0.03)"
                    : "rgba(255,255,255,0.03)",
              }}
              icon={<CircularProgress size={14} sx={{ mr: 0.5 }} />}
            />
          ) : isSearchingDoi ? (
            <Chip
              label="Searching..."
              color="info"
              size="small"
              variant="outlined"
              disabled
              icon={<CircularProgress size={14} />}
              sx={{
                height: 28,
                fontWeight: "regular",
                fontSize: "0.8125rem",
              }}
            />
          ) : paperData?.accessStatus &&
            paperData.accessStatus !== "Unknown" ? (
            <Chip
              label={paperData.accessStatus}
              color={getAccessStatusColor(paperData.accessStatus)}
              size="small"
              variant="outlined"
              sx={{
                height: 28,
                fontWeight: "regular",
                fontSize: "0.8125rem",
              }}
              icon={
                paperData.accessStatus === "Open Access" ? (
                  <CheckCircleIcon sx={{ fontSize: "0.875rem !important" }} />
                ) : (
                  <InfoIcon sx={{ fontSize: "0.875rem !important" }} />
                )
              }
            />
          ) : !foundDoi && !paperData?.doi && !showDoiChoices ? (
            <Chip
              label="Find Paper"
              color="info"
              size="small"
              variant="outlined"
              onClick={searchForDoi}
              icon={<SearchIcon sx={{ fontSize: "0.875rem !important" }} />}
              sx={{
                height: 28,
                fontWeight: "regular",
                fontSize: "0.8125rem",
                cursor: "pointer",
              }}
            />
          ) : null}
        </Stack>
        <IconButton onClick={onClose} aria-label="close">
          <CloseIcon />
        </IconButton>
      </DialogTitle>
      <DialogContent
        sx={{
          p: 0,
        }}
      >
        {isLoading && !isSearchingDoi ? (
          <Box
            sx={{
              display: "flex",
              flexDirection: "column",
              justifyContent: "center",
              alignItems: "center",
              height: "400px",
              p: 4,
            }}
          >
            <CircularProgress size={40} sx={{ mb: 2 }} />
            <Typography variant="body1" color="text.secondary">
              Loading paper details...
            </Typography>
          </Box>
        ) : error ? (
          <Box
            sx={{
              display: "flex",
              flexDirection: "column",
              justifyContent: "center",
              alignItems: "center",
              height: "300px",
              p: 4,
            }}
          >
            <Typography variant="h6" color="error" sx={{ mb: 2 }}>
              {error}
            </Typography>
            <Button
              variant="contained"
              href={getExternalUrl()}
              target="_blank"
              rel="noopener noreferrer"
            >
              Open in browser
            </Button>
          </Box>
        ) : (
          <Box sx={{ p: 3 }}>
            <Stack spacing={2.5}>
              {/* Title section */}
              <Box>
                {/* Show DOI choices if multiple matches found */}
                {showDoiChoices && doiChoices.length > 0 && (
                  <Box
                    sx={{
                      mb: 2,
                      p: 1.5,
                      borderRadius: 1,
                      bgcolor: (theme) =>
                        theme.palette.mode === "light"
                          ? "rgba(25, 118, 210, 0.05)"
                          : "rgba(66, 165, 245, 0.1)",
                      border: "1px solid",
                      borderColor: "primary.light",
                    }}
                  >
                    <Typography
                      variant="subtitle2"
                      sx={{
                        mb: 1,
                        display: "flex",
                        alignItems: "center",
                        gap: 0.5,
                      }}
                    >
                      <SearchIcon
                        fontSize="small"
                        color="primary"
                        sx={{ fontSize: 18 }}
                      />
                      Multiple papers found. Select the correct one:
                    </Typography>
                    <Stack spacing={0.75} sx={{ mt: 1 }}>
                      {doiChoices.map((choice, index) => (
                        <Box
                          key={index}
                          onClick={() => selectDoi(choice)}
                          sx={{
                            p: 1,
                            borderRadius: 1,
                            cursor: "pointer",
                            "&:hover": {
                              bgcolor: (theme) =>
                                theme.palette.mode === "light"
                                  ? "rgba(25, 118, 210, 0.1)"
                                  : "rgba(66, 165, 245, 0.15)",
                            },
                            bgcolor: (theme) =>
                              theme.palette.mode === "light"
                                ? "rgba(255, 255, 255, 0.8)"
                                : "rgba(0, 0, 0, 0.2)",
                            display: "flex",
                            flexDirection: "column",
                          }}
                        >
                          <Typography variant="body2" sx={{ fontWeight: 500 }}>
                            {choice.title}
                          </Typography>
                          <Typography
                            variant="caption"
                            sx={{ mt: 0.5, color: "text.secondary" }}
                          >
                            {choice.journal ? choice.journal + " • " : ""}
                            {choice.year ? choice.year : "Year unknown"}
                            {choice.similarity &&
                              ` • Match confidence: ${Math.round(choice.similarity * 100)}%`}
                          </Typography>
                        </Box>
                      ))}
                    </Stack>
                    <Box
                      sx={{
                        mt: 1.5,
                        display: "flex",
                        justifyContent: "space-between",
                      }}
                    >
                      <Button
                        size="small"
                        variant="text"
                        color="primary"
                        onClick={() => {
                          setShowDoiChoices(false);
                          searchForDoi();
                        }}
                        startIcon={<SearchIcon />}
                      >
                        Try new search
                      </Button>
                      <Button
                        size="small"
                        variant="text"
                        color="error"
                        onClick={() => setShowDoiChoices(false)}
                      >
                        Cancel
                      </Button>
                    </Box>
                  </Box>
                )}

                {/* Display error message if DOI search fails */}
                {errorMessage && !showDoiChoices && (
                  <Box
                    sx={{
                      mb: 1.5,
                      p: 1,
                      borderRadius: 1,
                      bgcolor: (theme) =>
                        theme.palette.mode === "light"
                          ? "rgba(211, 47, 47, 0.05)"
                          : "rgba(211, 47, 47, 0.12)",
                      display: "flex",
                      alignItems: "center",
                      gap: 1,
                    }}
                  >
                    <SearchIcon
                      fontSize="small"
                      color="error"
                      sx={{ fontSize: 16 }}
                    />
                    <Typography
                      variant="body2"
                      color="error.main"
                      sx={{ fontSize: "0.8125rem" }}
                    >
                      {errorMessage}{" "}
                      <Link
                        component="button"
                        underline="hover"
                        onClick={searchForDoi}
                        sx={{ fontSize: "0.8125rem", cursor: "pointer" }}
                      >
                        Try another search
                      </Link>
                    </Typography>
                  </Box>
                )}

                {/* Paper title */}
                <Typography
                  variant="h5"
                  sx={{
                    fontWeight: "500",
                    color: (theme) => theme.palette.text.primary,
                    lineHeight: 1.3,
                    mb: 1.5,
                    fontSize: { xs: "1.25rem", sm: "1.4rem" },
                  }}
                >
                  {paperData?.title || record.title}
                </Typography>
              </Box>

              {/* Authors & Publication info - clean minimalist style */}
              <Box sx={{ mt: -0.5 }}>
                {paperData?.authors && paperData.authors.length > 0 ? (
                  <Typography
                    variant="body1"
                    sx={{
                      mb: 1,
                      color: (theme) => theme.palette.text.secondary,
                      fontSize: "0.9375rem",
                    }}
                  >
                    {paperData.authors.map((author, index) => (
                      <span key={index}>
                        {index > 0 && ", "}
                        {author.name}
                      </span>
                    ))}
                  </Typography>
                ) : (
                  <Typography
                    variant="body1"
                    sx={{
                      mb: 1,
                      color: "text.disabled",
                      fontStyle: "italic",
                      fontSize: "0.9375rem",
                    }}
                  >
                    {isSearchingDoi
                      ? searchStage === "pubmed"
                        ? "Searching authors in PubMed..."
                        : searchStage === "crossref"
                          ? "Searching authors in CrossRef..."
                          : "Searching authors in Semantic Scholar..."
                      : "Author information unavailable"}
                  </Typography>
                )}

                <Stack
                  direction="row"
                  spacing={1.5}
                  alignItems="center"
                  flexWrap="wrap"
                  divider={
                    <Box
                      component="span"
                      sx={{ color: "text.secondary", opacity: 0.6 }}
                    >
                      •
                    </Box>
                  }
                  sx={{ opacity: 0.9 }}
                >
                  {paperData?.journal ? (
                    <Typography
                      variant="subtitle2"
                      color="text.secondary"
                      sx={{ fontStyle: "italic" }}
                    >
                      {paperData.journal}
                    </Typography>
                  ) : (
                    <Typography
                      variant="subtitle2"
                      sx={{
                        color: "text.disabled",
                        fontStyle: "italic",
                      }}
                    >
                      {isSearchingDoi
                        ? searchStage === "pubmed"
                          ? "Searching journal in PubMed..."
                          : searchStage === "crossref"
                            ? "Searching journal in CrossRef..."
                            : "Searching journal in Semantic Scholar..."
                        : "Journal unknown"}
                    </Typography>
                  )}

                  {paperData?.year ? (
                    <Typography variant="subtitle2" color="text.secondary">
                      {paperData.year}
                    </Typography>
                  ) : (
                    <Typography
                      variant="subtitle2"
                      sx={{
                        color: "text.disabled",
                        fontStyle: "italic",
                      }}
                    >
                      {isSearchingDoi
                        ? searchStage === "pubmed"
                          ? "Searching year in PubMed..."
                          : searchStage === "crossref"
                            ? "Searching year in CrossRef..."
                            : "Searching year in Semantic Scholar..."
                        : "Year unknown"}
                    </Typography>
                  )}

                  {paperData?.citations > 0 && (
                    <Typography variant="subtitle2" color="text.secondary">
                      {paperData.citations} citations
                    </Typography>
                  )}
                </Stack>
              </Box>

              {/* Abstract section with minimal styling and no background */}
              <Box
                sx={{
                  position: "relative",
                  mt: 0.5,
                }}
              >
                <Typography
                  variant="subtitle1"
                  sx={{
                    color: "text.primary",
                    fontWeight: "medium",
                    display: "flex",
                    alignItems: "center",
                    gap: 1,
                    mb: 1,
                  }}
                >
                  <DescriptionIcon fontSize="small" sx={{ opacity: 0.7 }} />
                  Abstract
                </Typography>

                <Box
                  sx={{
                    position: "relative",
                    maxHeight: "250px",
                    overflow: "auto",
                    p: 1.5,
                    borderRadius: 1.5,
                    backgroundColor: (theme) =>
                      theme.palette.mode === "light"
                        ? "rgba(0,0,0,0.01)"
                        : "rgba(255,255,255,0.01)",
                    boxShadow: (theme) =>
                      theme.palette.mode === "light"
                        ? "0 1px 2px rgba(0,0,0,0.07)"
                        : "0 1px 3px rgba(0,0,0,0.15)",
                    transition: "box-shadow 0.2s ease-in-out",
                    "&:hover": {
                      boxShadow: (theme) =>
                        theme.palette.mode === "light"
                          ? "0 2px 4px rgba(0,0,0,0.08)"
                          : "0 2px 6px rgba(0,0,0,0.2)",
                    },
                    // Custom scrollbar styling
                    "&::-webkit-scrollbar": {
                      width: "8px",
                      height: "8px",
                    },
                    "&::-webkit-scrollbar-track": {
                      background: "transparent",
                    },
                    "&::-webkit-scrollbar-thumb": {
                      background: (theme) =>
                        theme.palette.mode === "light"
                          ? "rgba(0,0,0,0.15)"
                          : "rgba(255,255,255,0.15)",
                      borderRadius: "4px",
                      transition: "background 0.2s ease",
                    },
                    "&::-webkit-scrollbar-thumb:hover": {
                      background: (theme) =>
                        theme.palette.mode === "light"
                          ? "rgba(0,0,0,0.25)"
                          : "rgba(255,255,255,0.25)",
                    },
                    // Firefox scrollbar
                    scrollbarWidth: "thin",
                    scrollbarColor: (theme) =>
                      theme.palette.mode === "light"
                        ? "rgba(0,0,0,0.15) transparent"
                        : "rgba(255,255,255,0.15) transparent",
                  }}
                >
                  <Typography
                    variant="body2"
                    sx={{
                      textAlign: "justify",
                      color: "text.primary",
                      lineHeight: 1.7,
                    }}
                  >
                    {/* Only show search text if originally no abstract was available */}
                    {isSearchingDoi &&
                    (!record.abstract || record.abstract === "")
                      ? searchStage === "pubmed"
                        ? "Searching for abstract in PubMed..."
                        : searchStage === "crossref"
                          ? "Searching for abstract in CrossRef..."
                          : "Searching for abstract in Semantic Scholar..."
                      : paperData?.abstract ||
                        record.abstract ||
                        "No abstract available"}
                  </Typography>
                </Box>
              </Box>

              {/* Action buttons - Simplified minimalist layout */}
              <Box sx={{ mt: 3 }}>
                <Typography
                  variant="subtitle1"
                  sx={{
                    color: "text.primary",
                    fontWeight: "medium",
                    mb: 1,
                    display: "flex",
                    alignItems: "center",
                    gap: 1,
                  }}
                >
                  <LibraryIcon fontSize="small" sx={{ opacity: 0.7 }} />
                  Access
                </Typography>
                <Grid container spacing={1} sx={{ mt: 0.5 }}>
                  {/* PDF download button */}
                  {paperData?.directPdfLink && (
                    <Grid item xs={4} sm={4} md={4}>
                      <Button
                        variant={
                          paperData.openAccess ? "contained" : "outlined"
                        }
                        fullWidth
                        color={paperData.openAccess ? "success" : "primary"}
                        href={paperData.directPdfLink}
                        target="_blank"
                        rel="noopener noreferrer"
                        startIcon={<PdfIcon />}
                        sx={{
                          borderRadius: 1.5,
                          textTransform: "none",
                          py: 0.75,
                          minHeight: "36px",
                          boxShadow: "none",
                          fontSize: "0.875rem",
                          "&:hover": {
                            boxShadow: "none",
                          },
                        }}
                      >
                        {paperData.openAccess ? "Full Text" : "PDF"}
                      </Button>
                    </Grid>
                  )}

                  {/* Publisher link */}
                  {(foundDoi || record.doi) && (
                    <Grid item xs={4} sm={4} md={4}>
                      <Button
                        variant="outlined"
                        fullWidth
                        href={`https://doi.org/${foundDoi || record.doi}`}
                        target="_blank"
                        rel="noopener noreferrer"
                        startIcon={<OpenInNewIcon />}
                        sx={{
                          borderRadius: 1.5,
                          textTransform: "none",
                          py: 0.75,
                          minHeight: "36px",
                          fontSize: "0.875rem",
                        }}
                      >
                        Publisher
                      </Button>
                    </Grid>
                  )}

                  {/* PubMed link if available */}
                  {paperData?.pubmedUrl && (
                    <Grid item xs={4} sm={4} md={4}>
                      <Button
                        variant="outlined"
                        fullWidth
                        href={paperData.pubmedUrl}
                        target="_blank"
                        rel="noopener noreferrer"
                        startIcon={<LibraryIcon />}
                        sx={{
                          borderRadius: 1.5,
                          textTransform: "none",
                          py: 0.75,
                          minHeight: "36px",
                          fontSize: "0.875rem",
                        }}
                      >
                        PubMed
                      </Button>
                    </Grid>
                  )}

                  {/* Semantic Scholar link if available */}
                  {paperData?.semanticScholarUrl && (
                    <Grid item xs={4} sm={4} md={4}>
                      <Button
                        variant="outlined"
                        fullWidth
                        href={paperData.semanticScholarUrl}
                        target="_blank"
                        rel="noopener noreferrer"
                        startIcon={<ScholarIcon />}
                        sx={{
                          borderRadius: 1.5,
                          textTransform: "none",
                          py: 0.75,
                          minHeight: "36px",
                          fontSize: "0.875rem",
                        }}
                      >
                        Semantic Scholar
                      </Button>
                    </Grid>
                  )}

                  {/* URL link if no DOI, PubMed, or Semantic Scholar */}
                  {!(
                    foundDoi ||
                    record.doi ||
                    paperData?.pubmedUrl ||
                    paperData?.semanticScholarUrl
                  ) &&
                    record.url && (
                      <Grid item xs={4} sm={4} md={4}>
                        <Button
                          variant="outlined"
                          fullWidth
                          href={record.url}
                          target="_blank"
                          rel="noopener noreferrer"
                          startIcon={<OpenInNewIcon />}
                          sx={{
                            borderRadius: 1.5,
                            textTransform: "none",
                            py: 0.75,
                            minHeight: "36px",
                            fontSize: "0.875rem",
                          }}
                        >
                          Source
                        </Button>
                      </Grid>
                    )}

                  {/* Google Scholar link */}
                  <Grid item xs={4} sm={4} md={4}>
                    <Button
                      variant="outlined"
                      fullWidth
                      href={getGoogleScholarUrl()}
                      target="_blank"
                      rel="noopener noreferrer"
                      startIcon={<ScholarIcon />}
                      sx={{
                        borderRadius: 1.5,
                        textTransform: "none",
                        py: 0.75,
                        minHeight: "36px",
                        fontSize: "0.875rem",
                      }}
                    >
                      Scholar
                    </Button>
                  </Grid>

                  {/* Sci-Hub link - only show when DOI is available */}
                  {(foundDoi || record.doi) &&
                    (!(paperData?.openAccess === true) ||
                      paperData?.accessStatus === "Subscription Required") && (
                      <Grid item xs={4} sm={4} md={4}>
                        <Button
                          variant="outlined"
                          fullWidth
                          color="error"
                          href={getSciHubUrl()}
                          target="_blank"
                          rel="noopener noreferrer"
                          startIcon={<KeyIcon />}
                          sx={{
                            borderRadius: 1.5,
                            textTransform: "none",
                            py: 0.75,
                            minHeight: "36px",
                            fontSize: "0.875rem",
                            // Ensure contrast in dark mode
                            borderColor: "error.main",
                            color: "error.main",
                          }}
                        >
                          Sci-Hub
                        </Button>
                      </Grid>
                    )}
                </Grid>
              </Box>
            </Stack>
          </Box>
        )}
      </DialogContent>
    </Dialog>
  );
};

const RecordCardContent = ({ record, fontSize, collapseAbstract }) => {
  const [readMoreOpen, toggleReadMore] = useToggle();
  const [previewOpen, togglePreview] = useToggle();
  const [accessStatus, setAccessStatus] = React.useState(null);

  // Check access status when the component mounts
  React.useEffect(() => {
    const checkAccessStatus = async () => {
      if (record.doi) {
        try {
          const openAlexUrl = `https://api.openalex.org/works/https://doi.org/${encodeURIComponent(record.doi)}`;
          const response = await fetch(openAlexUrl);

          if (response.ok) {
            const data = await response.json();

            if (data.open_access && data.open_access.is_oa) {
              setAccessStatus("open");
            } else if (data.open_access) {
              setAccessStatus("limited");
            } else {
              setAccessStatus("closed");
            }
          }
        } catch (err) {
          console.log("Error checking access status:", err);
          setAccessStatus("unknown");
        }
      }
    };

    checkAccessStatus();
  }, [record.doi]);

  // Get the eye icon color based on access status
  const getEyeIconColor = () => {
    switch (accessStatus) {
      case "open":
        return "success.main";
      case "limited":
        return "warning.main";
      case "closed":
        return "text.secondary"; // default color
      default:
        return "text.secondary"; // default color
    }
  };

  return (
    <CardContent aria-label="record title abstract" sx={{ m: 1 }}>
      <Stack spacing={2}>
        {/* Show the title */}
        <Typography
          variant={"h5"}
          sx={(theme) => ({
            fontWeight: theme.typography.fontWeightMedium,
            lineHeight: 1.4,
          })}
        >
          {/* No title, inplace text */}
          {(record.title === "" || record.title === null) && (
            <Box
              className={"fontSize" + fontSizeOptions[fontSize]}
              fontStyle="italic"
            >
              No title available
            </Box>
          )}

          {!(record.title === "" || record.title === null) && (
            <Box className={"fontSize" + fontSizeOptions[fontSize]}>
              {record.title}
            </Box>
          )}
        </Typography>
        <Divider />
        <Stack direction="row" spacing={1}>
          {!(record.doi === undefined || record.doi === null) && (
            <Tooltip title="Open DOI">
              <StyledIconButton
                className="record-card-icon"
                href={"https://doi.org/" + record.doi}
                target="_blank"
                rel="noreferrer"
              >
                <DOIIcon />
              </StyledIconButton>
            </Tooltip>
          )}

          {/* Add preview button with color based on access status */}
          {(record.doi !== undefined || record.url !== undefined) && (
            <Tooltip
              title={
                accessStatus === "open"
                  ? "Preview Open Access Paper"
                  : accessStatus === "limited"
                    ? "Preview Paper (Limited Access)"
                    : "Preview Paper"
              }
            >
              <StyledIconButton
                className="record-card-icon"
                onClick={togglePreview}
                sx={{ color: getEyeIconColor() }}
              >
                <VisibilityIcon />
              </StyledIconButton>
            </Tooltip>
          )}

          {!(record.url === undefined || record.url === null) && (
            <Tooltip title="Open URL">
              <StyledIconButton
                className="record-card-icon"
                href={record.url}
                target="_blank"
                rel="noreferrer"
              >
                <LinkIcon />
              </StyledIconButton>
            </Tooltip>
          )}

          {/* Paper Preview Dialog */}
          <PaperPreviewDialog
            open={previewOpen}
            onClose={togglePreview}
            record={record}
          />
        </Stack>
        <Box>
          {(record.abstract === "" || record.abstract === null) && (
            <Typography
              className={"fontSize" + fontSize}
              variant="body1"
              sx={{
                fontStyle: "italic",
                textAlign: "justify",
              }}
            >
              No abstract available
            </Typography>
          )}

          <Typography
            className={"fontSize" + fontSizeOptions[fontSize]}
            variant="body1"
            sx={{
              whiteSpace: "pre-line",
              textAlign: "justify",
              hyphens: "auto",
              lineHeight: 1.6,
            }}
          >
            {!(record.abstract === "" || record.abstract === null) &&
            collapseAbstract &&
            !readMoreOpen &&
            record.abstract.length > 500 ? (
              <>
                {record.abstract.substring(0, 500)}...
                <Link
                  component="button"
                  underline="none"
                  onClick={toggleReadMore}
                >
                  expand
                </Link>
              </>
            ) : (
              record.abstract
            )}
          </Typography>
        </Box>
        {record.keywords && (
          <Box sx={{ pt: 1 }}>
            <Typography sx={{ color: "text.secondary", fontWeight: "bold" }}>
              {record.keywords.map((keyword, index) => (
                <span key={index}>
                  {index > 0 && " • "}
                  {keyword}
                </span>
              ))}
            </Typography>
          </Box>
        )}
      </Stack>
    </CardContent>
  );
};

const RecordCard = ({
  project_id,
  record,
  afterDecision = null,
  retrainAfterDecision = true,
  showBorder = true,
  fontSize = 1,
  modelLogLevel = "warning",
  showNotes = true,
  collapseAbstract = false,
  hotkeys = false,
  transitionType = "fade",
  transitionSpeed = { enter: 500, exit: 100 },
  landscape = false,
  changeDecision = true,
}) => {
  const [open, setOpen] = React.useState(true);

  const styledRepoCard = (
    <Box>
      <RecordCardModelTraining
        record={record}
        modelLogLevel={modelLogLevel}
        sx={{ mb: 3, mx: 4 }}
      />
      <Card
        elevation={showBorder ? 4 : 0}
        sx={(theme) => ({
          bgcolor: theme.palette.background.record,
          borderRadius: !showBorder ? 0 : undefined,
        })}
      >
        <Grid container columns={5} sx={{ alignItems: "stretch" }}>
          <Grid size={landscape ? 3 : 5}>
            <RecordCardContent
              record={record}
              fontSize={fontSize}
              collapseAbstract={collapseAbstract}
            />
          </Grid>
          <Grid size={landscape ? 2 : 5}>
            <RecordCardLabeler
              key={
                "record-card-labeler-" +
                project_id +
                "-" +
                record?.record_id +
                "-" +
                record?.state?.note
              }
              project_id={project_id}
              record_id={record.record_id}
              label={record.state?.label}
              labelFromDataset={record.included}
              onDecisionClose={
                transitionType ? () => setOpen(false) : afterDecision
              }
              retrainAfterDecision={retrainAfterDecision}
              note={record.state?.note}
              labelTime={record.state?.time}
              user={record.state?.user}
              showNotes={showNotes}
              tagsForm={record.tags_form}
              tagValues={record.state?.tags}
              landscape={landscape}
              hotkeys={hotkeys}
              changeDecision={changeDecision}
            />
          </Grid>
        </Grid>
      </Card>
    </Box>
  );

  if (transitionType === "fade") {
    return (
      <Fade
        in={open}
        timeout={transitionSpeed}
        onExited={afterDecision}
        unmountOnExit
      >
        {styledRepoCard}
      </Fade>
    );
  } else if (transitionType === "collapse") {
    return (
      <Collapse
        in={open}
        timeout={transitionSpeed}
        onExited={afterDecision}
        unmountOnExit
      >
        {styledRepoCard}
      </Collapse>
    );
  } else {
    return styledRepoCard;
  }
};

export default RecordCard;
